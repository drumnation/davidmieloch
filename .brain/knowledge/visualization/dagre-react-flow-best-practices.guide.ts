const dagreReactFlowBestPracticesGuide = {
  topic: "Dagre Layouts with React Flow Integration",
  description: "Dagre is a JavaScript library for directed graph layouts that implements algorithms for positioning nodes and edges in a graph visualization. When integrated with React Flow, a powerful library for creating interactive node-based diagrams and flowcharts, developers can create sophisticated graph visualizations with automatic layout capabilities. This knowledge guide covers best practices for using dagre layout algorithms with React Flow to create well-organized, visually appealing, and performant graph visualizations.",
  relevance: "Graph visualizations are essential in many software applications, including data analysis tools, workflow systems, network topologies, organization charts, and system architectures. The ability to automatically layout complex graphs is crucial for creating readable and usable visualizations. Dagre's layout algorithms combined with React Flow's interactive capabilities enable developers to build powerful graph-based interfaces that dynamically organize themselves, significantly enhancing user experience and data comprehension.",
  notes: [
    "* Note: This information is based on best practices as of March 2023. Please refer to official documentation for updates.",
    "* Note: The integration approach may vary based on specific versions of dagre and React Flow.",
    "* Note: As of 2023, dagre-d3 is deprecated, and using dagre directly with React Flow is recommended.",
    "* Note: React Flow v11+ uses a different API than previous versions, so implementation details may vary."
  ],
  corePrinciples: [
    {
      name: "Separation of Layout Logic and Rendering",
      description: "A fundamental principle when integrating dagre with React Flow is maintaining a clear separation between layout calculation and rendering. Dagre should be used solely for computing node positions, while React Flow handles the rendering and interaction aspects. This separation ensures a clean architecture and allows each library to focus on its strengths. In practice, this means using dagre to calculate a layout, then applying those positions to the React Flow nodes state, rather than letting dagre directly manipulate the DOM. This approach gives you full control over when layouts are recalculated and how they're applied, which is crucial for performance optimization and handling user interactions properly."
    },
    {
      name: "Declarative Layout Configuration",
      description: "Dagre layouts should be configured declaratively, specifying desired constraints and preferences rather than imperative positioning. This involves setting parameters like node spacing, ranking direction, alignment, margins, and other layout options that influence how dagre positions elements. By maintaining layout configuration as a set of declarative options, you can ensure consistency across different graph instances, easily adjust layouts to different contexts, and create reusable layout presets for different visualization scenarios. This declarative approach aligns well with React's own paradigm and makes layout logic more maintainable and testable."
    },
    {
      name: "Layout Stability and Consistency",
      description: "Maintaining layout stability during updates is critical for usable graph visualizations. When the graph data changes, you should aim to preserve the existing layout as much as possible while accommodating the changes. This principle involves strategies like incremental layout updates, position diffing, and animation of transitions between layouts. Without proper stability management, graphs can completely reorganize with minor data changes, causing disorientation for users. Techniques like node pinning, layout caching, and selective recalculation help maintain a consistent user experience while still allowing the graph to evolve."
    },
    {
      name: "Performance-Conscious Layout Calculation",
      description: "Layout calculation can be computationally expensive, especially for large graphs. This principle involves optimizing when and how layouts are calculated to maintain responsive applications. Strategies include debouncing layout recalculation, computing layouts in web workers, implementing incremental layouts for partial updates, and optimizing the graph structure before layout. For graphs with hundreds of nodes, naively recalculating the entire layout on every change can cause significant performance issues. Instead, adopt techniques like lazy layout calculation, level-of-detail approaches, and virtualization to ensure performant visualizations even with large datasets."
    },
    {
      name: "User-Driven Layout Control",
      description: "While automatic layouts are powerful, users often need control over the positioning of specific elements. This principle involves implementing mechanisms for users to override or influence the automatic layout through interactions like dragging, pinning, or grouping nodes. A well-designed integration should balance automatic organization with user agency, allowing the layout algorithm to handle the overall structure while respecting user-defined constraints. This hybrid approach leads to more satisfying visualizations where the algorithm handles the heavy lifting, but users can fine-tune the results to match their mental model or highlight specific relationships."
    }
  ],
  warningsAndPitfalls: {
    description: "When integrating Dagre with React Flow, there are several common issues and pitfalls that developers should be aware of. These warnings can help you avoid problems and create more robust graph visualizations.",
    warnings: [
      {
        title: "Infinite Layout Recalculation Loops",
        description: "One of the most common issues is triggering infinite layout recalculation loops. This happens when a layout update causes a state change that triggers another layout update, creating an endless cycle that freezes the UI.",
        solution: "Always be careful with your dependency arrays in useEffect and useCallback hooks. When applying layout, make sure you're not inadvertently triggering another layout calculation. Use debouncing, memoization, and carefully structured dependency arrays to prevent loops. Consider using a layout version counter or deep comparison of graph structure to determine when a real layout update is needed.",
        codeExample: "```typescript\n// Example of preventing layout loops with proper dependencies\nconst [layoutVersion, setLayoutVersion] = useState(0);\n\n// This effect only runs when the graph structure or layout configuration changes\nuseEffect(() => {\n  const { nodes: layoutedNodes } = getLayoutedElements(nodes, edges, layoutOptions);\n  // Use a functional state update to avoid dependency on nodes\n  setNodes(prevNodes => {\n    // Only update if the new layout is significantly different\n    const hasSignificantChanges = checkForSignificantChanges(prevNodes, layoutedNodes);\n    return hasSignificantChanges ? layoutedNodes : prevNodes;\n  });\n}, [layoutVersion, layoutOptions]); // nodes and edges not in deps\n\n// Trigger layout recalculation only when necessary\nconst triggerLayout = useCallback(() => {\n  setLayoutVersion(v => v + 1);\n}, []);\n```"
      },
      {
        title: "Memory Leaks with Large Graphs",
        description: "Large graphs with hundreds of nodes can cause memory leaks, especially when layouts are recalculated frequently or when graph data is not properly cleaned up.",
        solution: "Implement proper cleanup in useEffect hooks. Consider implementing virtualization for large graphs to render only visible portions. For very large graphs, split the visualization into sections or implement level-of-detail rendering where distant or less important parts of the graph are simplified.",
        codeExample: "```typescript\n// Example of proper cleanup in useEffect\nuseEffect(() => {\n  let isMounted = true;\n  \n  // Async layout calculation for large graphs\n  const calculateLayout = async () => {\n    // Simulate expensive calculation\n    const result = await computeLayoutAsync(nodes, edges);\n    \n    // Prevent state updates if component unmounted\n    if (isMounted) {\n      setNodes(result.nodes);\n      setEdges(result.edges);\n    }\n  };\n  \n  calculateLayout();\n  \n  // Cleanup function to prevent memory leaks\n  return () => {\n    isMounted = false;\n    // Additional cleanup if needed\n  };\n}, [graphDataVersion]);\n```"
      },
      {
        title: "Layout Instability During Updates",
        description: "When updating graph data, the entire layout can drastically change even with minor modifications, creating a disorienting experience for users as nodes jump to new positions.",
        solution: "Implement position diffing and incremental updates. Maintain a reference to previous node positions and only update positions significantly different from prior layout. Consider adding animations for transitions between layouts. For real-time updates, implement position interpolation for smooth transitions.",
        codeExample: "```typescript\n// Example of maintaining position stability during updates\nconst previousPositions = useRef(new Map());\n\n// Store positions after each update\nuseEffect(() => {\n  const positionMap = new Map();\n  nodes.forEach(node => {\n    positionMap.set(node.id, { ...node.position });\n  });\n  previousPositions.current = positionMap;\n}, [nodes]);\n\n// Apply layout while preserving positions where possible\nconst applyStableLayout = (nodes, edges) => {\n  // Get new layout\n  const { nodes: calculatedNodes } = calculateLayout(nodes, edges);\n  \n  // Blend with previous positions for stability\n  return calculatedNodes.map(node => {\n    const prevPos = previousPositions.current.get(node.id);\n    if (!prevPos) return node; // New node, use calculated position\n    \n    // Calculate difference between old and new positions\n    const diffX = node.position.x - prevPos.x;\n    const diffY = node.position.y - prevPos.y;\n    \n    // Only apply significant changes (threshold = 50px)\n    if (Math.abs(diffX) > 50 || Math.abs(diffY) > 50) {\n      // Apply transition animation\n      return {\n        ...node,\n        style: { ...node.style, transition: 'transform 300ms ease-in-out' }\n      };\n    }\n    \n    // Keep the previous position for stability\n    return { ...node, position: prevPos };\n  });\n};\n```"
      },
      {
        title: "Performance Degradation with Large Graphs",
        description: "Layout calculation for large graphs can block the main thread, causing UI freezes and poor user experience, especially when layouts are recalculated frequently.",
        solution: "Move layout calculations to Web Workers for large graphs. Implement progressive loading and rendering for very large graphs. Use virtualization techniques to render only the visible portion of large graphs. Consider implementing level-of-detail rendering where the graph simplifies at lower zoom levels.",
        codeExample: "See the Web Worker implementation example below in additionalExamples section."
      },
      {
        title: "Edge Routing and Z-Index Issues",
        description: "Edges can appear to go through nodes or render incorrectly behind or in front of nodes, especially in dense layouts or when nodes overlap.",
        solution: "Configure React Flow with appropriate z-index values for nodes and edges. Consider using custom edge types with path finding algorithms for complex routing. Ensure sufficient node spacing in dagre configuration to minimize overlaps.",
        codeExample: "```typescript\n// Example of improving edge routing\nconst dagreGraph = new dagre.graphlib.Graph();\ndagreGraph.setGraph({\n  rankdir: direction,\n  nodesep: 80, // Increase node separation\n  ranksep: 200,\n  edgesep: 50, // Add edge separation\n  marginx: 50,\n  marginy: 50,\n  acyclicer: 'greedy', // Handle cycles in the graph\n});\n\n// Custom edge with improved routing\nconst CustomEdge = ({ id, source, target, style }) => {\n  // Calculate a better path for the edge\n  const [edgePath, labelX, labelY] = getBezierPath({\n    sourceX,\n    sourceY,\n    sourcePosition,\n    targetX,\n    targetY,\n    targetPosition,\n    curvature: 0.2, // Adjust path curvature\n  });\n  \n  return (\n    <><path\n      id={id}\n      className=\"react-flow__edge-path\"\n      d={edgePath}\n      style={style}\n    /></>\n  );\n};\n```"
      },
      {
        title: "Version Compatibility Issues",
        description: "Breaking changes between different versions of React Flow or dagre can cause unexpected behavior or errors.",
        solution: "Lock your dependencies to specific versions to ensure consistency. When upgrading, carefully review the changelog for breaking changes. Create a modular architecture where layout algorithms can be swapped out if needed.",
        codeExample: "```json\n// Example package.json with locked dependencies\n{\n  \"dependencies\": {\n    \"reactflow\": \"11.7.4\",\n    \"dagre\": \"0.8.5\",\n    \"@types/dagre\": \"0.7.48\"\n  }\n}\n```"
      },
      {
        title: "Mobile and Touch Interaction Issues",
        description: "Graph visualizations can be challenging to use on mobile devices due to small screens and touch interaction limitations.",
        solution: "Implement responsive layouts with different configurations for mobile devices. Enhance touch interactions with gesture support for pinch-to-zoom and multi-touch operations. Consider simplified views or alternative navigation methods for mobile users.",
        codeExample: "```typescript\n// Example of responsive configuration for different devices\nconst getLayoutOptions = () => {\n  // Detect mobile devices\n  const isMobile = window.innerWidth <= 768;\n  \n  return {\n    direction: isMobile ? 'TB' : 'LR', // Vertical layout on mobile\n    nodeSeparation: isMobile ? 50 : 100, // Smaller spacing on mobile\n    rankSeparation: isMobile ? 100 : 200,\n    // Additional mobile-specific settings\n    ...(isMobile && {\n      // Simplify graph for mobile if needed\n      simplifyGraph: true,\n      // Other mobile-specific options\n    }),\n  };\n};\n\n// Use ResizeObserver to update layout on window resize\nuseEffect(() => {\n  const resizeObserver = new ResizeObserver(() => {\n    const options = getLayoutOptions();\n    // Recalculate layout with new options\n    setLayoutOptions(options);\n  });\n  \n  resizeObserver.observe(containerRef.current);\n  \n  return () => resizeObserver.disconnect();\n}, []);\n```"
      }
    ]
  },
  additionalExamples: {
    description: "The following additional examples demonstrate specific techniques to address common challenges when working with Dagre and React Flow.",
    examples: [
      {
        name: "Web Worker Implementation for Dagre Layout",
        description: "For large graphs with hundreds of nodes, layout calculation can block the main thread and cause UI freezes. This example demonstrates how to move layout calculations to a Web Worker for improved performance.",
        example: "Below is an implementation of Dagre layout calculation in a Web Worker that keeps the UI responsive even with large graphs.\n\n```typescript\n// web-worker.ts (Layout worker)\nexport {}; // Ensure TypeScript treats this as a module\n\nself.onmessage = (event) => {\n  const { nodes, edges, options, id } = event.data;\n  \n  // Import dagre dynamically within the worker\n  // Note: This requires proper bundler configuration\n  import('dagre').then((dagre) => {\n    // Create dagre graph\n    const dagreGraph = new dagre.graphlib.Graph();\n    dagreGraph.setDefaultEdgeLabel(() => ({}));\n    dagreGraph.setGraph(options);\n    \n    // Add nodes and edges\n    nodes.forEach((node) => {\n      dagreGraph.setNode(node.id, {\n        width: node.width || 150,\n        height: node.height || 50,\n      });\n    });\n    \n    edges.forEach((edge) => {\n      dagreGraph.setEdge(edge.source, edge.target);\n    });\n    \n    // Calculate layout\n    dagre.layout(dagreGraph);\n    \n    // Extract positions\n    const positionedNodes = nodes.map((node) => {\n      const nodeWithPosition = dagreGraph.node(node.id);\n      return {\n        ...node,\n        position: {\n          x: nodeWithPosition.x - (node.width || 150) / 2,\n          y: nodeWithPosition.y - (node.height || 50) / 2,\n        },\n      };\n    });\n    \n    // Send result back to main thread\n    self.postMessage({\n      nodes: positionedNodes,\n      edges,\n      id, // Pass back request ID for correlation\n    });\n  }).catch((error) => {\n    self.postMessage({\n      error: error.message,\n      id,\n    });\n  });\n};\n\n// Main Component using the worker\nimport { useCallback, useEffect, useRef, useState } from 'react';\nimport ReactFlow, { useNodesState, useEdgesState } from 'reactflow';\n\nconst WorkerBasedLayout = ({ initialNodes, initialEdges, layoutOptions }) => {\n  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n  const [isCalculating, setIsCalculating] = useState(false);\n  const workerRef = useRef(null);\n  const requestIdRef = useRef(0);\n  \n  // Initialize worker\n  useEffect(() => {\n    // Create worker\n    workerRef.current = new Worker(new URL('./web-worker.ts', import.meta.url));\n    \n    // Set up message handler\n    workerRef.current.onmessage = (event) => {\n      const { nodes: layoutedNodes, edges: layoutedEdges, error, id } = event.data;\n      \n      // Ignore outdated responses\n      if (id !== requestIdRef.current) return;\n      \n      if (error) {\n        console.error('Layout calculation error:', error);\n      } else {\n        setNodes(layoutedNodes);\n        setEdges(layoutedEdges);\n      }\n      \n      setIsCalculating(false);\n    };\n    \n    // Clean up worker on unmount\n    return () => {\n      workerRef.current.terminate();\n    };\n  }, []);\n  \n  // Function to trigger layout calculation\n  const calculateLayout = useCallback(() => {\n    if (!workerRef.current || isCalculating) return;\n    \n    setIsCalculating(true);\n    \n    // Generate request ID to track responses\n    const requestId = ++requestIdRef.current;\n    \n    // Send data to worker\n    workerRef.current.postMessage({\n      nodes: nodes.map(node => ({\n        ...node,\n        // Include node dimensions for layout calculation\n        width: node.width || (node.type === 'special' ? 200 : 150),\n        height: node.height || (node.type === 'special' ? 100 : 50),\n      })),\n      edges,\n      options: layoutOptions,\n      id: requestId,\n    });\n  }, [nodes, edges, layoutOptions, isCalculating]);\n  \n  // Calculate layout on initial render and when dependencies change\n  useEffect(() => {\n    calculateLayout();\n  }, [calculateLayout]);\n  \n  return (\n    <div style={{ width: '100%', height: '600px' }}>\n      <ReactFlow\n        nodes={nodes}\n        edges={edges}\n        onNodesChange={onNodesChange}\n        onEdgesChange={onEdgesChange}\n        fitView\n      >\n        {isCalculating && (\n          <div className=\"layout-indicator\">\n            Calculating layout...\n          </div>\n        )}\
        <div className=\"controls\">\n          <button onClick={calculateLayout} disabled={isCalculating}>\n            {isCalculating ? 'Calculating...' : 'Recalculate Layout'}\n          </button>\n        </div>\n      </ReactFlow>\n    </div>\n  );\n};\n\nexport default WorkerBasedLayout;\n```\n\nThis implementation offers several benefits:\n1. The main thread remains responsive during layout calculations\n2. A loading indicator shows when calculation is in progress\n3. Request IDs ensure that only the most recent layout is applied\n4. Workers can be terminated properly to prevent memory leaks\n5. Error handling captures and reports issues in the worker"
      },
      {
        name: "Incremental Layout Updates",
        description: "For graphs that receive frequent updates, recalculating the entire layout each time can be disorienting for users. This example demonstrates how to implement incremental layout updates that preserve the overall structure while accommodating changes.",
        example: "This example shows a technique for incremental layout updates that maintain stability during frequent data changes.\n\n```typescript\nimport { useCallback, useEffect, useRef, useState } from 'react';\nimport ReactFlow, { useNodesState, useEdgesState, Node, Edge } from 'reactflow';\nimport dagre from 'dagre';
import { isEqual } from 'lodash';

// Function to calculate node changes between updates
const getNodeChanges = (prevNodes, newNodes) => {\n  const changes = {\n    added: [],\n    removed: [],\n    unchanged: [],\n  };\n  \n  // Find added and unchanged nodes
newNodes.forEach(node => {\n    const existingNode = prevNodes.find(n => n.id === node.id);\n    if (!existingNode) {\n      changes.added.push(node);\n    } else {\n      // Check if data has changed
const hasDataChanged = !isEqual(existingNode.data, node.data);\n      changes.unchanged.push({\n        ...node,\n        dataChanged: hasDataChanged,\n        // Preserve position from existing node
position: existingNode.position,\n      });\n    }\n  });\n  \n  // Find removed nodes
prevNodes.forEach(node => {\n    if (!newNodes.find(n => n.id === node.id)) {\n      changes.removed.push(node);\n    }\n  });\n  \n  return changes;\n};\n

// Function for incremental layout calculation
const calculateIncrementalLayout = (prevNodes, newNodes, edges, options) => {\n  if (!prevNodes.length || !newNodes.length) {\n    // Initial layout or complete refresh needed
return calculateFullLayout(newNodes, edges, options);\n  }\n  \n  // Analyze changes
const changes = getNodeChanges(prevNodes, newNodes);\n  \n  // If substantial changes (>30% nodes changed), do full layout
const changeRatio = (changes.added.length + changes.removed.length) / prevNodes.length;\n  if (changeRatio > 0.3) {\n    return calculateFullLayout(newNodes, edges, options);\n  }\n  \n  // For minor changes, do incremental layout
const dagreGraph = new dagre.graphlib.Graph();\ndagreGraph.setDefaultEdgeLabel(() => ({}));\ndagreGraph.setGraph(options);\n \n  // Add all nodes to dagre - keeping existing positions for unchanged nodes
const combinedNodes = [\n    ...changes.unchanged,\n    ...changes.added.map(node => ({\n      ...node,\n      // Place new nodes near related ones or at default position
position: findRelatedNodePosition(node, changes.unchanged, edges) || { x: 0, y: 0 },\n    })),\n  ];\n  \n  // Add nodes to dagre
combinedNodes.forEach(node => {\ndagreGraph.setNode(node.id, {\n      width: node.width || 150,\n      height: node.height || 50,\n      // For unchanged nodes, fix their position in dagre
fixed: !changes.added.find(n => n.id === node.id),\n    });\n  });\n  \n  // Add edges
edges.forEach(edge => {\ndagreGraph.setEdge(edge.source, edge.target);\n  });\n  \n  // Run layout - this will only move new nodes while respecting fixed ones
dagre.layout(dagreGraph);\n  \n  // Get positioned nodes
const resultNodes = combinedNodes.map(node => {\n    // For new nodes, get position from dagre
if (changes.added.find(n => n.id === node.id)) {\n      const nodeWithPosition = dagreGraph.node(node.id);\n      return {\n        ...node,\n        position: {\n          x: nodeWithPosition.x - (node.width || 150) / 2,\n          y: nodeWithPosition.y - (node.height || 50) / 2,\n        },\n        // Add transition for smooth appearance
style: { ...node.style, opacity: 0, transition: 'opacity 300ms ease-in-out' },\n        data: { ...node.data, fadeIn: true },\n      };\n    }\n    \n    // Return unchanged nodes with their existing positions
return node;\n  });\n  \n  return { nodes: resultNodes, edges };\n};\n

// Helper to find a good position for new nodes based on connections
const findRelatedNodePosition = (node, existingNodes, edges) => {\n  // Find connected edges for this node
const connectedEdges = edges.filter(\n    edge => edge.source === node.id || edge.target === node.id\n  );\n  \n  if (!connectedEdges.length) return null;\n  \n  // Find existing nodes connected to this one
const connectedNodeIds = connectedEdges.map(edge => \n    edge.source === node.id ? edge.target : edge.source\n  );\n  \n  const connectedNodes = existingNodes.filter(n => \n    connectedNodeIds.includes(n.id)\n  );\n  \n  if (!connectedNodes.length) return null;\n  \n  // Calculate average position of connected nodes as starting point
const avgX = connectedNodes.reduce((sum, n) => sum + n.position.x, 0) / connectedNodes.length;\n  const avgY = connectedNodes.reduce((sum, n) => sum + n.position.y, 0) / connectedNodes.length;\n  \n  // Add a small random offset to avoid exact overlapping
return {\n    x: avgX + (Math.random() - 0.5) * 50,\n    y: avgY + (Math.random() - 0.5) * 50,\n  };\n};\n

// Regular full layout calculation
const calculateFullLayout = (nodes, edges, options) => {\n  // Standard dagre layout implementation
// (similar to the layout functions shown in previous examples)\n  // ...\n};\n

const IncrementalLayoutFlow = ({ data, updateInterval = 5000 }) => {\n  const [nodes, setNodes, onNodesChange] = useNodesState([]);\n  const [edges, setEdges, onEdgesChange] = useEdgesState([]);\n  const prevNodesRef = useRef([]);\n  \n  // Process data updates incrementally
useEffect(() => {\n    if (!data) return;\n    \n    // Transform data to nodes and edges
const { nodes: newNodes, edges: newEdges } = transformData(data);\n    \n    // Calculate incremental layout
const layoutResult = calculateIncrementalLayout(\n      prevNodesRef.current,\n      newNodes,\n      newEdges,\n      { rankdir: 'LR', nodesep: 80, ranksep: 200 }\n    );\n    \n    // Update state
setNodes(layoutResult.nodes);\n    setEdges(layoutResult.edges);\n    \n    // Store current nodes for next comparison
prevNodesRef.current = layoutResult.nodes;\n    \n    // Handle fade-in animation for new nodes
const fadeInTimeoutId = setTimeout(() => {\n      setNodes(nodes => \n        nodes.map(node => {\n          if (node.data?.fadeIn) {\n            return {\n              ...node,\n              style: { ...node.style, opacity: 1 },\n              data: { ...node.data, fadeIn: false },\n            };\n          }\n          return node;\n        })\n      );\n    }, 10);\n    \n    return () => clearTimeout(fadeInTimeoutId);\n  }, [data]);\n  \n  return (\n    <ReactFlow\n      nodes={nodes}\n      edges={edges}\n      onNodesChange={onNodesChange}\n      onEdgesChange={onEdgesChange}\n      fitView\n    />\n  );\n};\n\nexport default IncrementalLayoutFlow;\n```\n\nKey features of this incremental layout approach:\n1. It analyzes the differences between previous and new node sets\n2. For small changes, it preserves existing node positions\n3. It places new nodes near their connected nodes for context\n4. It falls back to full layout for substantial changes (>30% of nodes)\n5. It applies animations for smooth transitions when nodes are added\n6. It uses fixed positions in dagre to constrain the layout algorithm"
      }
    ]
  },
  applicationProcess: {
    description: "The process of integrating dagre layouts with React Flow involves several interconnected steps, from setting up the environment to handling dynamic updates and user interactions. Each step requires careful consideration of architecture, performance, and user experience aspects.",
    steps: [
      {
        stepName: "Environment Setup and Dependencies",
        stepDescription: "The first step involves setting up your development environment with the necessary libraries and dependencies. This includes installing React Flow, dagre, and any supplementary packages needed for your specific use case. It's important to understand the version compatibility between these libraries and any associated type definitions for TypeScript projects.",
        agentActions: [
          "Action 1: Install the required dependencies using npm or yarn. For a typical setup, you'll need: `npm install reactflow dagre @types/dagre` (if using TypeScript).",
          "Action 2: Create a new React component or identify an existing component where the graph visualization will be implemented.",
          "Action 3: Import the necessary modules in your component file: `import ReactFlow, { Node, Edge, Position } from 'reactflow'; import dagre from 'dagre';`.",
          "Action 4: Add the React Flow CSS import statement: `import 'reactflow/dist/style.css';`.",
          "Action 5: Verify the installation by creating a minimal React Flow component without dagre integration to ensure the basic functionality works."
        ]
      },
      {
        stepName: "Graph Data Structure Definition",
        stepDescription: "Before applying any layout algorithm, you need to define the structure of your graph. This involves creating the nodes and edges data structures that React Flow will render. The data structure should be designed to accommodate both the visual aspects needed by React Flow and any additional data required by your application logic.",
        agentActions: [
          "Action 1: Define a nodes array conforming to React Flow's Node interface, including at minimum `id`, `position`, and `data` properties for each node. The initial position can be arbitrary as dagre will recalculate it.",
          "Action 2: Define an edges array conforming to React Flow's Edge interface, including at minimum `id`, `source`, and `target` properties for each edge.",
          "Action 3: If using TypeScript, create appropriate type definitions for your node and edge data to ensure type safety throughout your application.",
          "Action 4: Establish a state management approach for your graph data, either using React's useState/useReducer or an external state management library.",
          "Action 5: Implement functions to manipulate the graph data (add/remove/update nodes and edges) that will be used in response to user actions or external data changes."
        ]
      },
      {
        stepName: "Dagre Layout Function Implementation",
        stepDescription: "This step involves creating a utility function that applies the dagre layout algorithm to your graph data. This function will transform the positions of your nodes according to dagre's layout algorithms while preserving all other properties and data.",
        agentActions: [
          "Action 1: Create a utility function (e.g., `getLayoutedElements`) that takes nodes and edges arrays as input and returns new arrays with updated node positions.",
          "Action 2: Within this function, create a new dagre graph instance and configure its settings like direction, node separation, rank separation, etc.",
          "Action 3: Add all nodes and edges to the dagre graph instance, providing necessary information like dimensions for each node.",
          "Action 4: Run the dagre layout algorithm on the graph instance using `dagre.layout(g)`.",
          "Action 5: Extract the calculated positions from the dagre graph and apply them to your React Flow nodes array, returning the updated array.",
          "Action 6: Ensure the function handles special cases like nodes with fixed positions (if your application supports pinning nodes)."
        ]
      },
      {
        stepName: "Integration with React Flow Component",
        stepDescription: "This step connects the layout function with your React Flow component, ensuring that the graph is laid out automatically when needed. This includes setting up the necessary state, effects, and event handlers to manage the graph visualization lifecycle.",
        agentActions: [
          "Action 1: Initialize your React Flow component with the nodes and edges states, typically using React's useState hook.",
          "Action 2: Create a layout effect (useLayoutEffect) that applies the dagre layout function to your initial nodes and edges and updates the state.",
          "Action 3: Implement event handlers for React Flow events like `onNodesChange` and `onEdgesChange` to update your graph state when users interact with the visualization.",
          "Action 4: Add controls for users to trigger layout recalculation, adjust layout parameters, or reset the view.",
          "Action 5: Ensure your component correctly handles prop changes that might require layout recalculation, such as changes to the underlying data or layout configuration."
        ]
      },
      {
        stepName: "Optimizing Layout Updates and Performance",
        stepDescription: "To ensure a smooth user experience, especially with larger graphs, you need to optimize when and how layout calculations are performed. This step involves implementing strategies to minimize unnecessary recalculations and ensure responsive performance.",
        agentActions: [
          "Action 1: Implement debouncing for layout recalculation to prevent multiple consecutive layouts when data changes rapidly.",
          "Action 2: Use React's useMemo hook to cache layout results based on relevant dependencies to avoid recalculation when unrelated state changes.",
          "Action 3: For larger graphs, consider using web workers to perform layout calculations off the main thread to prevent UI freezing.",
          "Action 4: Implement incremental layout updates for scenarios where only a portion of the graph changes, avoiding full recalculation.",
          "Action 5: Add a loading indicator or animation when layout calculation is in progress, especially for larger graphs where the process might take noticeable time."
        ]
      },
      {
        stepName: "Handling User Interactions and Manual Positioning",
        stepDescription: "A well-designed graph visualization allows users to interact with and modify the layout. This step involves implementing features that let users manually position nodes, pin them in place, or trigger specific layout actions.",
        agentActions: [
          "Action 1: Modify your nodes data structure to include a 'fixed' or 'pinned' property that can be toggled by user actions.",
          "Action 2: Update your layout function to respect pinned nodes, preserving their positions during automatic layout.",
          "Action 3: Implement double-click or right-click handlers to allow users to pin/unpin nodes at specific positions.",
          "Action 4: Add UI controls for users to select different layout configurations (e.g., horizontal vs. vertical flow) and apply them on demand.",
          "Action 5: Implement zoom and pan functionality to help users navigate larger graphs, utilizing React Flow's built-in features."
        ]
      },
      {
        stepName: "Styling and Customizing Visual Appearance",
        stepDescription: "The visual presentation of your graph impacts its readability and usability. This step involves customizing the appearance of nodes, edges, and the overall graph to suit your application's needs and design language.",
        agentActions: [
          "Action 1: Create custom node types by implementing React components that render nodes with specific visual styles and interactive elements.",
          "Action 2: Define custom edge types with appropriate styling, potentially including animated or interactive edges.",
          "Action 3: Implement visual indicators for different node and edge states, such as selection, hover, error, or processing states.",
          "Action 4: Configure React Flow's styling options for the canvas, background, and controls to match your application's design.",
          "Action 5: Use CSS or styled-components to create a consistent visual language for your graph elements that aligns with your application's overall design system."
        ]
      },
      {
        stepName: "Responsive Design and Adaptability",
        stepDescription: "Graphs should adapt to different screen sizes and container dimensions. This step involves making your visualization responsive and implementing strategies for different viewing contexts.",
        agentActions: [
          "Action 1: Use React Flow's fitView functionality to ensure the graph is properly scaled within its container.",
          "Action 2: Implement media queries or dynamic style adjustments to modify node sizes, fonts, and spacing based on the available screen space.",
          "Action 3: Create alternative layout configurations for different device types (e.g., more compact layouts for mobile).",
          "Action 4: Use the ResizeObserver API or a resize-aware container to detect size changes and trigger appropriate layout updates.",
          "Action 5: Implement a 'mini-map' for larger graphs on smaller screens to help with navigation."
        ]
      }
    ]
  },
  examples: {
    description: "The following examples demonstrate practical applications of dagre layouts with React Flow in different contexts. Each example illustrates specific techniques and approaches to solve common graph visualization challenges.",
    useCases: [
      {
        name: "Process Workflow Diagram",
        scenario: "A business process management application that needs to visualize workflows with sequential steps, decision points, and parallel processes. The layout must clearly show the flow direction and relationships between steps while allowing users to edit the workflow structure.",
        example: "In this scenario, we create a workflow diagram where each node represents a process step and edges represent transitions between steps. We use dagre to automatically organize the workflow in a top-to-bottom layout that clearly shows the sequence and branching of steps.\n\n```typescript\nimport { useCallback, useLayoutEffect, useState } from 'react';\nimport ReactFlow, {\n  addEdge,\n  ConnectionLineType,\n  Panel,\n  useEdgesState,\n  useNodesState,\n  Node,\n  Edge,\n} from 'reactflow';\nimport dagre from 'dagre';\nimport 'reactflow/dist/style.css';\n\n// Define custom node types and their dimensions for accurate layout\nconst nodeTypes = {\n  task: { width: 180, height: 70 },\n  decision: { width: 100, height: 100 },\n  start: { width: 150, height: 50 },\n  end: { width: 150, height: 50 },\n};\n\n// Layout direction can be TB (top to bottom) or LR (left to right)\nconst getLayoutedElements = (nodes: Node[], edges: Edge[], direction = 'TB') => {\n  // Create a new dagre graph\n  const dagreGraph = new dagre.graphlib.Graph();\n  dagreGraph.setDefaultEdgeLabel(() => ({}));\n  \n  // Set graph direction and spacing\n  dagreGraph.setGraph({ rankdir: direction, nodesep: 50, ranksep: 200 });\n\n  // Add nodes to dagre with their dimensions\n  nodes.forEach((node) => {\n    const nodeType = node.type || 'task';\n    const dimensions = nodeTypes[nodeType as keyof typeof nodeTypes];\n    \n    dagreGraph.setNode(node.id, { \n      width: dimensions.width,\n      height: dimensions.height\n    });\n  });\n\n  // Add edges to dagre\n  edges.forEach((edge) => {\n    dagreGraph.setEdge(edge.source, edge.target);\n  });\n\n  // Apply the layout\n  dagre.layout(dagreGraph);\n\n  // Get the new node positions from dagre\n  const layoutedNodes = nodes.map((node) => {\n    const nodeWithPosition = dagreGraph.node(node.id);\n    \n    // Skip nodes that are pinned (user-positioned)\n    if (node.data?.pinned) {\n      return node;\n    }\n    \n    // Center the node based on its dimensions\n    return {\n      ...node,\n      position: {\n        x: nodeWithPosition.x - (nodeTypes[node.type as keyof typeof nodeTypes]?.width || 0) / 2,\n        y: nodeWithPosition.y - (nodeTypes[node.type as keyof typeof nodeTypes]?.height || 0) / 2,\n      },\n    };\n  });\n\n  return { nodes: layoutedNodes, edges };\n};\n\nconst WorkflowDiagram = () => {\n  // Define initial nodes and edges for the workflow\n  const initialNodes: Node[] = [\n    { id: 'start', type: 'start', data: { label: 'Start Process' }, position: { x: 0, y: 0 } },\n    { id: 'task1', type: 'task', data: { label: 'Review Application' }, position: { x: 0, y: 0 } },\n    { id: 'decision', type: 'decision', data: { label: 'Approved?' }, position: { x: 0, y: 0 } },\n    { id: 'task2', type: 'task', data: { label: 'Process Approval' }, position: { x: 0, y: 0 } },\n    { id: 'task3', type: 'task', data: { label: 'Send Rejection' }, position: { x: 0, y: 0 } },\n    { id: 'end', type: 'end', data: { label: 'End Process' }, position: { x: 0, y: 0 } },\n  ];\n\n  const initialEdges: Edge[] = [\n    { id: 'e1', source: 'start', target: 'task1', type: 'smoothstep' },\n    { id: 'e2', source: 'task1', target: 'decision', type: 'smoothstep' },\n    { id: 'e3', source: 'decision', target: 'task2', type: 'smoothstep', label: 'Yes' },\n    { id: 'e4', source: 'decision', target: 'task3', type: 'smoothstep', label: 'No' },\n    { id: 'e5', source: 'task2', target: 'end', type: 'smoothstep' },\n    { id: 'e6', source: 'task3', target: 'end', type: 'smoothstep' },\n  ];\n\n  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n  const [layoutDirection, setLayoutDirection] = useState('TB');\n\n  // Apply layout when component mounts or layout direction changes\n  useLayoutEffect(() => {\n    const { nodes: layoutedNodes, edges: layoutedEdges } = getLayoutedElements(\n      nodes,\n      edges,\n      layoutDirection\n    );\n    \n    setNodes([...layoutedNodes]);\n    setEdges([...layoutedEdges]);\n  }, [layoutDirection]);\n\n  // Handle new connections between nodes\n  const onConnect = useCallback((params) => {\n    // Create a new edge with smoothstep appearance\n    setEdges((eds) => addEdge({ ...params, type: 'smoothstep' }, eds));\n    \n    // Re-apply layout after adding a new connection\n    setTimeout(() => {\n      const { nodes: layoutedNodes, edges: layoutedEdges } = getLayoutedElements(\n        nodes,\n        edges,\n        layoutDirection\n      );\n      \n      setNodes([...layoutedNodes]);\n      setEdges([...layoutedEdges]);\n    }, 10);\n  }, [nodes, edges, layoutDirection]);\n\n  // Toggle node pinning on double-click\n  const onNodeDoubleClick = useCallback((event, node) => {\n    setNodes(\n      nodes.map((n) => {\n        if (n.id === node.id) {\n          // Toggle pinned status\n          return {\n            ...n,\n            data: {\n              ...n.data,\n              pinned: !n.data?.pinned,\n            },\n          };\n        }\n        return n;\n      })\n    );\n  }, [nodes]);\n\n  // Function to toggle layout direction\n  const toggleDirection = useCallback(() => {\n    setLayoutDirection((current) => (current === 'TB' ? 'LR' : 'TB'));\n  }, []);\n\n  return (\n    <div style={{ width: '100%', height: '600px' }}>\n      <ReactFlow\n        nodes={nodes}\n        edges={edges}\n        onNodesChange={onNodesChange}\n        onEdgesChange={onEdgesChange}\n        onConnect={onConnect}\n        onNodeDoubleClick={onNodeDoubleClick}\n        connectionLineType={ConnectionLineType.SmoothStep}\n        fitView\n      >\n        <Panel position=\"top-right\">\n          <button onClick={toggleDirection}>\n            Direction: {layoutDirection === 'TB' ? 'Top-Bottom' : 'Left-Right'}\n          </button>\n        </Panel>\n      </ReactFlow>\n    </div>\n  );\n};\n\nexport default WorkflowDiagram;\n```\n\nThis example demonstrates several key best practices:\n1. It defines node dimensions for each type to ensure accurate layout calculations\n2. It implements node pinning to allow users to override the automatic layout for specific nodes\n3. It provides a direction toggle to switch between vertical and horizontal layouts\n4. It applies layout both on initial render and when the graph structure changes\n5. It uses smoothstep edges for a clean visual appearance"
      },
      {
        name: "Hierarchical Organization Chart",
        scenario: "An HR application that visualizes company structure with departments, teams, and reporting relationships. The chart must effectively show the hierarchical nature of the organization while handling potentially large and complex structures.",
        example: "For an organization chart, we create a hierarchical visualization that shows reporting relationships clearly. We use dagre's ability to create layered layouts to represent the organizational hierarchy, with customizations to handle potentially large organizational structures.\n\n```typescript\nimport { useCallback, useEffect, useState } from 'react';\nimport ReactFlow, {\n  Background,\n  Controls,\n  MiniMap,\n  Node,\n  Edge,\n  useNodesState,\n  useEdgesState,\n} from 'reactflow';\nimport dagre from 'dagre';\nimport 'reactflow/dist/style.css';\n\n// Custom node component for employees\nconst EmployeeNode = ({ data }) => {\n  return (\n    <div className={`employee-node ${data.role}`}>\n      <img src={data.avatar} alt={data.name} className=\"avatar\" />\n      <div className=\"details\">\n        <div className=\"name\">{data.name}</div>\n        <div className=\"title\">{data.title}</div>\n        <div className=\"department\">{data.department}</div>\n      </div>\n    </div>\n  );\n};\n\n// Register custom node type\nconst nodeTypes = {\n  employee: EmployeeNode,\n};\n\n// Function to get node width based on role\nconst getNodeWidth = (role) => {\n  switch (role) {\n    case 'executive': return 280;\n    case 'manager': return 240;\n    case 'team-lead': return 220;\n    default: return 200;\n  }\n};\n\n// Function to get node height based on role\nconst getNodeHeight = (role) => {\n  switch (role) {\n    case 'executive': return 100;\n    case 'manager': return 90;\n    case 'team-lead': return 80;\n    default: return 70;\n  }\n};\n\n// Configure layout with dagre\nconst getLayoutedElements = (nodes, edges, options = {}) => {\n  const dagreGraph = new dagre.graphlib.Graph();\n  dagreGraph.setDefaultEdgeLabel(() => ({}));\n  \n  const {\n    direction = 'TB',\n    nodeSeparation = 100,\n    rankSeparation = 200,\n    rankDir = direction,\n  } = options;\n  \n  dagreGraph.setGraph({\n    rankdir: rankDir,\n    nodesep: nodeSeparation,\n    ranksep: rankSeparation,\n    align: 'UL', // Upper left alignment helps with readability\n    acyclicer: 'greedy', // Helps with cyclic graphs if they occur\n    ranker: 'network-simplex', // Usually provides the best layout for org charts\n  });\n\n  // Add nodes with their dimensions\n  nodes.forEach((node) => {\n    const role = node.data?.role || 'employee';\n    dagreGraph.setNode(node.id, {\n      width: getNodeWidth(role),\n      height: getNodeHeight(role),\n    });\n  });\n\n  // Add edges\n  edges.forEach((edge) => {\n    dagreGraph.setEdge(edge.source, edge.target);\n  });\n\n  // Calculate layout\n  dagre.layout(dagreGraph);\n\n  // Apply calculated positions to the nodes\n  const layoutedNodes = nodes.map((node) => {\n    const nodeWithPosition = dagreGraph.node(node.id);\n    const role = node.data?.role || 'employee';\n    \n    // If this is a manually positioned node, respect its position\n    if (node.data?.manuallyPositioned) {\n      return node;\n    }\n    \n    return {\n      ...node,\n      position: {\n        x: nodeWithPosition.x - (nodeTypes[node.type as keyof typeof nodeTypes]?.width || 0) / 2,\n        y: nodeWithPosition.y - (nodeTypes[node.type as keyof typeof nodeTypes]?.height || 0) / 2,\n      },\n    };\n  });\n\n  return { nodes: layoutedNodes, edges };\n};\n\n// Generate edges based on parent-child relationships\nconst createEdgesFromHierarchy = (employees) => {\n  const edges = [];\n  employees.forEach(employee => {\n    if (employee.managerId) {\n      edges.push({\n        id: `e${employee.managerId}-${employee.id}`,\n        source: employee.managerId,\n        target: employee.id,\n        type: 'smoothstep',\n        animated: false,\n        style: { stroke: '#b1b1b7' },\n      });\n    }\n  });\n  return edges;\n};\n\n// Convert employee data to React Flow nodes\nconst createNodesFromEmployees = (employees) => {\n  return employees.map(employee => ({\n    id: employee.id,\n    type: 'employee',\n    data: {\n      ...employee,\n      label: employee.name,\n    },\n    position: { x: 0, y: 0 }, // Initial position, will be calculated by dagre\n  }));\n};\n\nconst OrganizationChart = ({ employeeData, layoutOptions = {} }) => {\n  const [nodes, setNodes, onNodesChange] = useNodesState([]);\n  const [edges, setEdges, onEdgesChange] = useEdgesState([]);\n  \n  // Apply dagre layout when data changes\n  useEffect(() => {\n    if (!employeeData?.length) return;\n    \n    // Create initial nodes and edges from data\n    const initialNodes = createNodesFromEmployees(employeeData);\n    const initialEdges = createEdgesFromHierarchy(employeeData);\n    \n    // Get the initial layout\n    const { nodes: layoutedNodes, edges: layoutedEdges } = getLayoutedElements(\n      initialNodes,\n      initialEdges,\n      layoutOptions\n    );\n    \n    setNodes(layoutedNodes);\n    setEdges(layoutedEdges);\n  }, [employeeData, layoutOptions]);\n\n  // Handle node dragging to allow manual positioning\n  const onNodeDragStop = useCallback((event, node) => {\n    // Mark the node as manually positioned\n    setNodes(nodes.map(n => {\n      if (n.id === node.id) {\n        return {\n          ...n,\n          data: {\n            ...n.data,\n            manuallyPositioned: true\n          }\n        };\n      }\n      return n;\n    }));\n  }, [nodes]);\n\n  // Reset layout and remove manual positioning\n  const resetLayout = useCallback(() => {\n    // Remove manual positioning flags\n    const updatedNodes = nodes.map(node => ({\n      ...node,\n      data: {\n        ...node.data,\n        manuallyPositioned: false\n      }\n    }));\n    \n    // Recalculate layout\n    const { nodes: layoutedNodes, edges: layoutedEdges } = getLayoutedElements(\n      updatedNodes,\n      edges,\n      layoutOptions\n    );\n    \n    setNodes(layoutedNodes);\n    setEdges(layoutedEdges);\n  }, [nodes, edges, layoutOptions]);\n\n  return (\n    <div style={{ width: '100%', height: '800px' }}>\n      <ReactFlow\n        nodes={nodes}\n        edges={edges}\n        onNodesChange={onNodesChange}\n        onEdgesChange={onEdgesChange}\n        onNodeDragStop={onNodeDragStop}\n        nodeTypes={nodeTypes}\n        fitView\n        fitViewOptions={{ padding: 0.2 }}\n        minZoom={0.1}\n      >\n        <Controls />\n        <Background />\n        <MiniMap\n          nodeColor={(node) => {\n            switch (node.data?.role) {\n              case 'executive': return '#a1cfff';\n              case 'manager': return '#9dffce';\n              case 'team-lead': return '#ffd89d';\n              default: return '#f7f7f7';\n            }\n          }}\n        />\n        <div className=\"controls-panel\">\n          <button onClick={resetLayout}>Reset Layout</button>\n        </div>\n      </ReactFlow>\n    </div>\n  );\n};\n\nexport default OrganizationChart;\n```\n\nThis example showcases:\n1. Custom node components with role-based styling and dimensions\n2. Hierarchical data transformation from a flat employee list with parent references\n3. Layout optimization with different node sizes based on organizational role\n4. Support for manual node positioning with the ability to reset the layout\n5. Visual aids like a mini-map with role-based coloring for easier navigation"
      },
      {
        name: "Dynamic Network Topology Visualization",
        scenario: "A network monitoring application that needs to display real-time updates to network topology, including devices, connections, and status information. The visualization must handle frequent updates without disorienting users.",
        example: "For a network topology visualization, we create a system that dynamically updates as network data changes while maintaining stability in the layout. This example demonstrates handling real-time updates efficiently with dagre and React Flow.\n\n```typescript\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport ReactFlow, {\n  Background,\n  Controls,\n  ReactFlowProvider,\n  Node,\n  Edge,\n  useNodesState,\n  useEdgesState,\n  applyNodeChanges,\n  applyEdgeChanges,\n} from 'reactflow';\nimport dagre from 'dagre';\nimport 'reactflow/dist/style.css';\n\n// Node dimensions by device type\nconst nodeConfig = {\n  router: { width: 180, height: 100 },\n  switch: { width: 150, height: 80 },\n  firewall: { width: 180, height: 90 },\n  server: { width: 160, height: 120 },\n  client: { width: 120, height: 60 },\n  default: { width: 150, height: 80 },\n};\n\n// Node styling by status\nconst getNodeStyles = (status) => {\n  switch (status) {\n    case 'online': return { borderColor: '#22c55e', backgroundColor: '#f0fdf4' };\n    case 'offline': return { borderColor: '#ef4444', backgroundColor: '#fef2f2' };\n    case 'warning': return { borderColor: '#f59e0b', backgroundColor: '#fffbeb' };\n    case 'unknown': return { borderColor: '#6b7280', backgroundColor: '#f9fafb' };\n    default: return { borderColor: '#3b82f6', backgroundColor: '#eff6ff' };\n  }\n};\n\n// Edge styling by connection type and status\nconst getEdgeStyles = (type, status) => {\n  const baseStyle = {\n    strokeWidth: type === 'fiber' ? 3 : type === 'ethernet' ? 2 : 1,\n  };\n  \n  switch (status) {\n    case 'active': return { ...baseStyle, stroke: '#22c55e' };\n    case 'inactive': return { ...baseStyle, stroke: '#ef4444' };\n    case 'degraded': return { ...baseStyle, stroke: '#f59e0b' };\n    default: return { ...baseStyle, stroke: '#94a3b8' };\n  }\n};\n\n// Custom node component\nconst NetworkDeviceNode = ({ data }) => {\n  const styles = getNodeStyles(data.status);\n  \n  return (\n    <div className={`network-device ${data.type}`} style={styles}>\n      <div className=\"icon-container\">\n        <img src={data.icon} alt={data.type} />\n      </div>\n      <div className=\"device-info\">\n        <div className=\"device-name\">{data.name}</div>\n        <div className=\"device-ip\">{data.ip}</div>\n        <div className=\"device-stats\">\n          {data.stats && `${data.stats.cpu}% CPU | ${data.stats.memory}% MEM`}\n        </div>\n      </div>\n      <div className={`status-indicator status-${data.status}`} />\n    </div>\n  );\n};\n\n// Node types registration\nconst nodeTypes = {\n  networkDevice: NetworkDeviceNode,\n};\n\n// Layout calculation function\nconst calculateLayout = (nodes, edges, options = {}) => {\n  if (!nodes.length) return { nodes, edges };\n  \n  const dagreGraph = new dagre.graphlib.Graph();\n  dagreGraph.setDefaultEdgeLabel(() => ({}));\n  \n  const {\n    direction = 'LR',\n    nodeSeparation = 100,\n    rankSeparation = 200,\n  } = options;\n  \n  dagreGraph.setGraph({\n    rankdir: direction,\n    nodesep: nodeSeparation,\n    ranksep: rankSeparation,\n    marginx: 50,\n    marginy: 50,\n  });\n\n  // Add nodes with their dimensions\n  nodes.forEach((node) => {\n    const deviceType = node.data?.type || 'default';\n    const dimensions = nodeConfig[deviceType] || nodeConfig.default;\n    \n    dagreGraph.setNode(node.id, dimensions);\n  });\n\n  // Add edges\n  edges.forEach((edge) => {\n    dagreGraph.setEdge(edge.source, edge.target);\n  });\n\n  // Calculate layout\n  dagre.layout(dagreGraph);\n\n  // Get node positions from dagre\n  const positionedNodes = nodes.map((node) => {\n    // Skip manually positioned nodes\n    if (node.data?.manualPosition) {\n      return node;\n    }\n    \n    const nodeWithPosition = dagreGraph.node(node.id);\n    const deviceType = node.data?.type || 'default';\n    const dimensions = nodeConfig[deviceType] || nodeConfig.default;\n    \n    // Keep the nodes at the same position if they're already rendered\n    // and only slightly adjust as needed - this maintains stability\n    if (node.position && node.positionAbsolute) {\n      // Calculate the difference between current and new position\n      const diffX = nodeWithPosition.x - dimensions.width / 2 - node.position.x;\n      const diffY = nodeWithPosition.y - dimensions.height / 2 - node.position.y;\n      \n      // Only update position if the difference is significant (threshold of 50px)\n      if (Math.abs(diffX) > 50 || Math.abs(diffY) > 50) {\n        return {\n          ...node,\n          position: {\n            x: nodeWithPosition.x - dimensions.width / 2,\n            y: nodeWithPosition.y - dimensions.height / 2,\n          },\n          // Animate the transition to the new position\n          style: { ...node.style, transition: 'transform 500ms ease' },\n        };\n      }\n      return node;\n    }\n    \n    // Position for new nodes\n    return {\n      ...node,\n      position: {\n        x: nodeWithPosition.x - dimensions.width / 2,\n        y: nodeWithPosition.y - dimensions.height / 2,\n      },\n    };\n  });\n\n  return { nodes: positionedNodes, edges };\n};\n\n// Transform network data to React Flow nodes and edges\nconst transformNetworkData = (networkData) => {\n  // Create nodes\n  const nodes = networkData.devices.map((device) => ({\n    id: device.id,\n    type: 'networkDevice',\n    data: {\n      ...device,\n      label: device.name,\n    },\n    position: { x: 0, y: 0 },\n  }));\n\n  // Create edges\n  const edges = networkData.connections.map((connection) => ({\n    id: connection.id,\n    source: connection.source,\n    target: connection.target,\n    animated: connection.status === 'active' && connection.traffic > 70,\n    style: getEdgeStyles(connection.type, connection.status),\n    data: connection,\n  }));\n\n  return { nodes, edges };\n};\n\nconst NetworkTopology = ({ networkData, pollingInterval = 30000 }) => {\n  const [nodes, setNodes, onNodesChange] = useNodesState([]);\n  const [edges, setEdges, onEdgesChange] = useEdgesState([]);\n  const [layoutDirection, setLayoutDirection] = useState('LR');\n  const previousPositions = useRef(new Map());\n  \n  // Store the previous positions when nodes update\n  useEffect(() => {\n    const positionMap = new Map();\n    nodes.forEach(node => {\n      positionMap.set(node.id, { ...node.position });\n    });\n    previousPositions.current = positionMap;\n  }, [nodes]);\n\n  // Process network data into nodes and edges, preserving positions\n  const processNetworkUpdate = useCallback((data) => {\n    // Transform network data to nodes and edges\n    const { nodes: newNodes, edges: newEdges } = transformNetworkData(data);\n    \n    // Preserve existing positions for stable updates\n    const nodesWithPositions = newNodes.map(node => {\n      const prevPosition = previousPositions.current.get(node.id);\n      if (prevPosition) {\n        return {\n          ...node,\n          position: prevPosition,\n        };\n      }\n      return node;\n    });\n    \n    // Calculate the layout while maintaining stability\n    const layoutOptions = {\n      direction: layoutDirection,\n      nodeSeparation: 120,\n      rankSeparation: 250,\n    };\n    \n    const { nodes: layoutedNodes, edges: layoutedEdges } = calculateLayout(\n      nodesWithPositions,\n      newEdges,\n      layoutOptions\n    );\n    \n    // Apply updates with a debounce to prevent visual jitter\n    setNodes(layoutedNodes);\n    setEdges(layoutedEdges);\n  }, [layoutDirection]);\n\n  // Process initial data and set up polling for updates\n  useEffect(() => {\n    // Initial processing\n    if (networkData) {\n      processNetworkUpdate(networkData);\n    }\n    \n    // Set up polling interval for data updates if needed\n    const intervalId = setInterval(() => {\n      // In a real application, you would fetch fresh data here\n      if (networkData) {\n        processNetworkUpdate(networkData);\n      }\n    }, pollingInterval);\n    \n    return () => clearInterval(intervalId);\n  }, [networkData, pollingInterval, processNetworkUpdate]);\n\n  // Custom node change handler to support pin/unpin functionality\n  const handleNodesChange = useCallback((changes) => {\n    // Apply node changes to state\n    setNodes(nds => {\n      const updatedNodes = applyNodeChanges(changes, nds);\n      \n      // Check for node selection changes to enable pinning/unpinning\n      const selectionChanges = changes.filter(\n        change => change.type === 'select'\n      );\n      \n      if (selectionChanges.length) {\n        return updatedNodes.map(node => {\n          const change = selectionChanges.find(c => c.id === node.id);\n          if (change) {\n            // Toggle the manual position flag on selection\n            return {\n              ...node,\n              data: {\n                ...node.data,\n                manualPosition: change.selected\n              }\n            };\n          }\n          return node;\n        });\n      }\n      \n      return updatedNodes;\n    });\n  }, []);\n\n  // Toggle layout direction\n  const toggleDirection = useCallback(() => {\n    setLayoutDirection(prev => {\n      const newDirection = prev === 'LR' ? 'TB' : 'LR';\n      \n      // Recalculate layout with new direction\n      const { nodes: layoutedNodes, edges: layoutedEdges } = calculateLayout(\n        nodes,\n        edges,\n        {\n          direction: newDirection,\n          nodeSeparation: 120,\n          rankSeparation: 250,\n        }\n      );\n      \n      // Update nodes and edges with the new layout\n      setNodes(layoutedNodes);\n      setEdges(layoutedEdges);\n      \n      return newDirection;\n    });\n  }, [nodes, edges]);\n\n  return (\n    <div style={{ width: '100%', height: '800px' }}>\n      <ReactFlowProvider>\n        <ReactFlow\n          nodes={nodes}\n          edges={edges}\n          onNodesChange={handleNodesChange}\n          onEdgesChange={onEdgesChange}\n          nodeTypes={nodeTypes}\n          fitView\n          minZoom={0.1}\n          maxZoom={1.5}\n        >\n          <Controls />\n          <Background color=\"#f5f5f5\" variant=\"dots\" />\n          <div className=\"control-panel\">\n            <button onClick={toggleDirection}>\n              {layoutDirection === 'LR' ? 'Horizontal' : 'Vertical'} Layout\n            </button>\n            <button onClick={() => {\n              // Reset manual positions\n              setNodes(nodes.map(node => ({\n                ...node,\n                data: { ...node.data, manualPosition: false }\n              })));\n              \n              // Recalculate layout\n              const { nodes: layoutedNodes, edges: layoutedEdges } = calculateLayout(\n                nodes,\n                edges,\n                { direction: layoutDirection }\n              );\n              \n              setNodes(layoutedNodes);\n              setEdges(layoutedEdges);\n            }}>\n              Reset Layout\n            </button>\n          </div>\n        </ReactFlow>\n      </ReactFlowProvider>\n    </div>\n  );\n};\n\nexport default NetworkTopology;\n```\n\nThis example demonstrates advanced techniques for dynamic data visualization:\n1. Efficient handling of real-time updates with position stability\n2. Visual status indication through node and edge styling\n3. Animation for active connections with high traffic\n4. Smooth transitions when layout changes occur\n5. Node pinning with selection-based toggling\n6. Polling mechanism for regular data updates\n7. Position memory to prevent disorienting jumps during updates"
      }
    ]
  }
}











